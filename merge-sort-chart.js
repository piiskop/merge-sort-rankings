/**
 * @author kalmer
 * @var array matches where every match is an object whose property
 *      <code>winner</code> has a value as the name of the winner and property
 *      <code>looser</code> has the value of the looser's name
 */

var matches = [
//       		{
//    				'winner' : 'kalmer',
//    				'looser' : 'mari'
//    			},
//    		{
//    				'winner' : 'kalmer',
//    				'looser' : 'boris'
//    			},
//    		{
//    				'winner' : 'ivar',
//    				'looser' : 'kalmer'
//    			},
//    		{
//    				'winner' : 'jakov',
//    				'looser' : 'kalmer'
//    			},
//    		{
//    				'winner' : 'marek',
//    				'looser' : 'kalmer'
//    			},
//    		{
//    				'winner' : 'kristjan',
//    				'looser' : 'ivar'
//    			},
//    		{
//    				'winner' : 'kristjan',
//    				'looser' : 'malle'
//    			},
//    		{
//    				'winner' : 'malle',
//    				'looser' : 'ivar'
//    			},
//    		{
//    				'winner' : 'kristjan',
//    				'looser' : 'jakov'
//    			},
//    		{
//    				'winner' : 'taavi',
//    				'looser' : 'kristjan'
//    			},
//    		{
//    				'winner' : 'kalmer',
//    				'looser' : 'kristjan'
//    			},



               {
	winner : 'rainer',
	looser : 'illimar'
}, {
	winner : 'tarmo',
	looser : 'rainer'
}, {
	winner : 'kristjan',
	looser : 'kalmer'
}, {
	winner : 'per',
	looser : 'rando'
}, {
	winner : 'ülle',
	looser : 'riina'
}, {
	winner : 'kalmer',
	looser : 'aivar'
}, {
	winner : 'stiina',
	looser : 'ülle'
}, {
	winner : 'riina',
	looser : 'helena'
},
{
	winner : 'boris',
	looser : 'aivar'
},
{
	winner : 'ahto',
	looser : 'ville'
}, {
	winner : 'tarmo',
	looser : 'indrek'
}, {
	winner : 'tarmo',
	looser : 'ahto'
}, {
	winner : 'kristi',
	looser : 'helena'
}, {
	winner : 'ranno',
	looser : 'tarmo'
}, {
	winner : 'ranno',
	looser : 'per'
}, {
	winner : 'külli',
	looser : 'katrin'
}, {
	winner : 'kristiina',
	looser : 'stiina'
}, {
	winner : 'genadi',
	looser : 'aivar'
}, {
	winner : 'kalmer',
	looser : 'boris'
}, {
	winner : 'kalmer',
	looser : 'genadi'
}, {
	winner : 'indrek',
	looser : 'rando'
}, {
	winner : 'per',
	looser : 'genadi'
}, {
	winner : 'ivar',
	looser : 'ville'
}, {
	winner : 'per',
	looser : 'indrek'
}, {
	winner : 'riina',
	looser : 'kristi'
}, {
	winner : 'ivar',
	looser : 'indrek'
}, {
	winner : 'tarmo',
	looser : 'per'
}, {
	winner : 'ivar',
	looser : 'priit'
}, {
	winner : 'kristiina',
	looser : 'külli'
}, {
	winner : 'kristiina',
	looser : 'janelle'
}, {
	winner : 'indrek',
	looser : 'illimar'
}, {
	winner : 'janelle',
	looser : 'riina'
}, {
	winner : 'külli',
	looser : 'janelle'
}, {
	winner : 'kaie',
	looser : 'helena'
}, {
	winner : 'ahto',
	looser : 'rainer'
}, {
	winner : 'stiina',
	looser : 'janelle'
}, {
	winner : 'ivar',
	looser : 'ranno'
}, {
	winner : 'rainer',
	looser : 'ville'
}, {
	winner : 'rando',
	looser : 'ahto'
}, {
	winner : 'stiina',
	looser : 'külli'
}, {
	winner : 'aivar',
	looser : 'ahto'
}, {
	winner : 'boris',
	looser : 'genadi'
}, {
	winner : 'stiina',
	looser : 'katrin'
}, {
	winner : 'ivar',
	looser : 'kalmer'
}, {
	winner : 'genadi',
	looser : 'indrek'
}, {
	winner : 'boris',
	looser : 'priit'
}, {
	winner : 'ville',
	looser : 'illimar'
}, {
	winner : 'aivar',
	looser : 'indrek'
}, {
	winner : 'kristi',
	looser : 'kaie'
}, {
	winner : 'kalmer',
	looser : 'tarmo'
}, {
	winner : 'katrin',
	looser : 'riina'
}, {
	winner : 'kristjan',
	looser : 'ivar'
}, {
	winner : 'priit',
	looser : 'indrek'
}, {
	winner : 'illimar',
	looser : 'rando'
}, {
	winner : 'boris',
	looser : 'tarmo'
}, {
	winner : 'illimar',
	looser : 'rando'
}, {
	winner : 'ahto',
	looser : 'illimar'
}, {
	winner : 'illimar',
	looser : 'stiina'
}, {
	winner : 'kristiina',
	looser : 'indrek'
}, {
	winner : 'aivar',
	looser : 'kristiina'
}, {
	winner : 'janelle',
	looser : 'katrin'
}, {
	winner : 'illimar',
	looser : 'rando'
}, {
	winner : 'rando',
	looser : 'stiina'
}, {
	winner : 'ville',
	looser : 'stiina'
}, {
	winner : 'priit',
	looser : 'per'
}, {
	winner : 'kalmer',
	looser : 'indrek'
}, {
	winner : 'kalmer',
	looser : 'kristjan'
}, {
	winner : 'kalmer',
	looser : 'kristjan'
}, {
	winner : 'boris',
	looser : 'indrek'
} ];
// var matches = [
//               {
//            	   'winner': 'kristjan',
//            	   'looser': 'kalmer'
//               },
//               {
//            	   'winner': 'kalmer',
//            	   'looser': 'aivar'
//               },
//               {
//            	   'winner': 'boris',
//            	   'looser': 'aivar'
//               },
//
//               ];
/**
 * @access private
 * @author kalmer
 * @var multitype[string] a recursive array of the result of the merging. Every
 *      player has his/her own subarray like this:
 * 
 * <pre>
 *  [kalmer] =&gt; Array
 *     (
 *         [player] =&gt; kalmer
 *         [winners] =&gt; Array
 *             (
 *             )
 * 
 *         [place] =&gt; 1
 *     )
 * 		
 * </pre><code>winners</code> contains the arrays of winners of the current player.
 */
var results = [];

/**
 * This function cleans the winners recursively if the looser has won over
 * his/her previous winner.
 * 
 * @access private
 * @author kalmer
 * @param boolean
 *            $parameters['deep'] Are we digged in recursively?
 * @param mixed[int]
 *            $parameters['results'] the actual results of merging of the winner
 * @param string
 *            $parameters['winner'] the name of the winner
 * @param string
 *            $parameters['looser'] the name of the looser
 * @param string
 *            $parameters['parent'] the name of the parent
 */
function cleanWinner(parameters) {
	// console.log(" 255: " + cleanWinner.caller.name);
	// if the winner has an entry for his/her winners
	if (isset(parameters.results) && isset(parameters['results']['winners'])) {

		// for each player who has won over the current winner
		for (player in parameters['results']['winners']) {
			// if we are at the first level
			if (!parameters['deep']) {
				// set the parent to be the current player
				parameters['parent'] = player;
			}

			// if the looser is the current player
			if (parameters['looser'] === player) {
				// remove the parent from the winners over the winner
				delete (results[parameters['winner']]['winners'][parameters['parent']]);
				// for each player
				for (previousLooser in results) {
					// if the player has set winners
					if (isset(results[previousLooser]['winners'])) {
						// for each past winner
						for (previousWinner in results[previousLooser]['winners']) {
							// if the past winner is the current winner
							if (previousWinner === parameters['winner']) {

								/*
								 * remove the past winner from the list of
								 * winners over the past looser
								 */
								delete (results[previousLooser]['winners'][previousWinner]);
								/*
								 * insert the parent to the list of winners over
								 * the past looser
								 */
								results[previousLooser]['winners'][parameters['parent']] = results[parameters['parent']];

								// update loosers of the past looser
								updateLooser({
									'looser' : previousLooser
								});
							}
						}
					}
				}
			}
			// console.log(" 299: "+ parameters['results']['winners'][player]);
			// clean winners
			cleanWinner({
				'deep' : true,
				'results' : parameters['results']['winners'][player],
				'winner' : parameters['winner'],
				'looser' : parameters['looser'],
				'parent' : parameters['parent']
			});
		}
	}
}

/**
 * This function creates the chart using merge sorting.
 * 
 * @access public
 * @author kalmer
 * @param string[string[int]]
 *            $parameters['matches'] the matches where the index is
 *            <code>winner</code> or <code>looser</code> and the value is
 *            the name of either winner or looser
 */
function manageResults(parameters) {

	// for each match result
	for (match in parameters['matches']) {
		// if there is no entry for the winner yet
		if (!isset(results[parameters['matches'][match]['winner']])) {
			// set an entry for the winner
			results[parameters['matches'][match]['winner']] = {
				'player' : parameters['matches'][match]['winner'],
				'winners' : {}
			};
			// console.log(" 333 ");
		}
		// console.log(" 334:
		// "+results[parameters['matches'][match]['winner']].toSource());
		/*
		 * manage all the cases where the winner has previously lost to somebody
		 * in the winner’s winners’ critical path
		 */
		cleanWinner({
			'deep' : false,
			'results' : results[parameters['matches'][match]['winner']],
			'winner' : parameters['matches'][match]['winner'],
			'looser' : parameters['matches'][match]['looser'],
			'parent' : null
		});
		// console.log(" 345: "+
		// results[parameters['matches'][match]['winner']].toSource());
		// set an entry for the looser
		if (!isset(results[parameters['matches'][match]['looser']])) {
			results[parameters['matches'][match]['looser']] = {
				winners : {}
			};
		}
		results[parameters['matches'][match]['looser']]['player'] = parameters['matches'][match]['looser'];
		// insert the list of the winner to the winners' list of the looser
		results[parameters['matches'][match].looser].winners[parameters['matches'][match].winner] = results[parameters['matches'][match]['winner']];
		// console.log(" 356: " +
		// results[parameters['matches'][match]['winner']].toSource());
		// update loosers of the looser
		updateLooser({
			'looser' : parameters['matches'][match]['looser']
		});
	}

	// for each player
	for (player in results) {
		// if there is an entry for the winners by the player
		if (isset(results[player]['winners'])) {
			/*
			 * set the place of the player according to the length of the
			 * critical path of the player's winners
			 */
			results[player]['place'] = array_depth({
				'array' : results[player],
				'keyForChildren' : 'winners'
			}) - 1;
		}
		// otherwise
		else {
			// set the place as 1 for the player
			results[player]['place'] = 1;
		}

	}
	sortedArray = array_sort(results);
	for (player in sortedArray) {
		console.log(' 629: <br/>', player, ', (', sortedArray[player]['place'],
				')');
	}

}

/**
 * This function sorts an array.
 * 
 * @author kalmer
 * @param arrayIn the array to sort
 * @returns {Array} the sorted array
 */
function array_sort(arrayIn) {

	var arrayCouplets = new Array();
	for (key in arrayIn) {

		arrayCouplets.push({

			key : key,
			value : arrayIn[key]
		});
	}

	arrayCouplets.sort(function(a, b) {
		console.log(" 443: " + a.value.place + ", " + b.value.place);
		if (a.value.place < b.value.place) {
			return -1;
		}
		if (a.value.place > b.value.place) {
			return 1;
		}
		return 0;
	});

	var arrayOut = new Array();
	for (i in arrayCouplets) {

		arrayOut[arrayCouplets[i]['key']] = arrayCouplets[i]['value'];
	}

	return arrayOut;
}

/**
 * This function finds out the depth of the array.
 * 
 * @access private
 * @author kalmer
 * @param mixed
 *            $parameters['array'] the array
 * @param string
 *            $parameters['keyForChildren'] the key for the children
 * @return number the depth
 */
var array_depth = function(parameters) {
//	    var level = 1;
//	    var key;
//	    for(key in parameters.array) {
//	        if (!parameters.array.hasOwnProperty(key)) continue;
//
//	        if(typeof parameters.array[key] == 'object'){
//	            var depth = array_depth(parameters.array[key]) + 1;
//	            level = Math.max(depth, level);
//	        }
//	    }
//	    return level;
	    
	    
	    
		if (!empty(parameters['array'][parameters['keyForChildren']])) {
		parameters['array'] = parameters['array'][parameters['keyForChildren']];
	}

	var max_depth = 1;

	for (index in parameters['array']) {
		if (is_object(parameters['array'][index])) {
			depth = array_depth({
				'array' : parameters['array'][index],
				'keyForChildren' : parameters['keyForChildren']
			}) + 1;
			if (depth > max_depth) {
				max_depth = depth;
			}
		}
	}

	return max_depth;
}

/**
 * This function updates recursively the loosers with the information about
 * their winners.
 * 
 * @access private
 * @author kalmer
 * @param string
 *            $parameters['looser'] the name of the looser
 */
var updateLooser = function(parameters) {

	// for each player
	for (player in results) {

		/*
		 * if the looser exists in the list of the winners over the current
		 * player
		 */
		if (isset(results[player]['winners'][parameters['looser']])) {
			/*
			 * update the list of the looser in the winners' list of the current
			 * player with the list of the looser
			 */
			results[player]['winners'][parameters['looser']] = results[parameters['looser']];
			// update loosers of the player
			updateLooser({
				'looser' : player
			});
		}

	}

}

manageResults({
	matches : matches
});
